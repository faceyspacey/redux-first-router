// @flow
import type { Navigators, Route, NavigationAction } from './flow-types'

import setKind from './pure-utils/setKind'

export default (
  navigators: Navigators,
  action: Object,
  navigationAction: ?NavigationAction,
  route: ?Route
): Object => {
  let kind: ?string
  let navKey: ?string = action.navKey

  // if it's a regular location-aware action, try to find its matching
  // React Navigation action:
  if (!navigationAction && action.meta && action.meta.location) {
    // for regular actions that aren't triggered by React Navigation UI
    // elements we automate navKey discovery using the routesMap:
    if (route && typeof route.navKey === 'string' && route.navKey) {
      navKey = route.navKey
    }

    kind = action.meta.location.kind

    let path = action.meta.location.current.pathname

    if (path[0] === '/') {
      path = path.substr(1) // react navigation paths dont start with slashes
    }

    const query = stringify(action.payload)
    const pathAndQuery = query ? `${path}?${query}` : path
    const navKeys = navKey ? [navKey] : Object.keys(navigators)

    navKeys.find((key: string) => {
      const navigator = navigators[key]

      if (!navigator) {
        return false
      }

      const router = navigator.router
      const action = router.getActionForPathAndParams(pathAndQuery)

      if (action) {
        // minor optimization that prevents pushing the previous route
        // it also allows for support for the `back` function
        if (kind === 'back') {
          action.type = 'Navigation/BACK'
        }

        navigationAction = action
        navKey = key
        return true
      }

      return false
    })
  }

  // All actions--if they have matching routes--at this point will be formated
  // as location-aware actions. But we may discover its `navigationAction`
  // in multiple places:
  //
  // -at the beginning of the middleware for Navigation actions generated by
  // React Navigation UI
  //
  // -and by trying to convert a location-aware action to one as we do above
  //
  // In both cases, we may end up with a `navigationAction` which we
  // need to assign to the meta of our main location-aware action, which is
  // we why make that assignment in a separate if statement here.
  //
  // NOTE: The routers' `getStateForAction` method will attempt to use the
  // action from meta if available.
  if (navigationAction && action.meta) {
    action.meta.navigation = navigationAction
    navigationAction.navKey = navKey

    switch (navigationAction.type) {
      case 'Navigation/BACK':
        setKind(action, 'back')
        break
      case 'Navigation/SET_PARAMS':
        setKind(action, 'redirect')
        break
      case 'Navigation/RESET':
        setKind(action, 'reset')
        break
      default:
        setKind(action, kind || 'push')
    }
  }

  action.navKey = navKey

  return action
}

const stringify = (obj: Object) =>
  Object.keys(obj).map(key => `${key}=${obj[key]}`).join('&')
